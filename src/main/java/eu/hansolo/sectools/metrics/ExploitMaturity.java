package eu.hansolo.sectools.metrics;


public enum ExploitMaturity implements Metric {
    NOT_DEFINED("Not Defined", "x", "X"),
    ATTACKED("Attacked", "a", "A"),
    PROOF_OF_CONCEPT("Proof of concept", "p", "P"),
    UNREPORTED("Unreported", "u", "U"),
    HIGH("High", "h", "H"),
    FUNCTIONAL("Functional", "f", "F"),
    UNPROVEN("Unproven", "u", "U"),
    NOT_FOUND("", "", "");

    public static final String METRIC_SHORT = "E";
    public final String uiString;
    public final String apiString;
    public final String shortForm;


    ExploitMaturity(final String uiString, final String apiString, final String shortForm) {
        this.uiString  = uiString;
        this.apiString = apiString;
        this.shortForm = shortForm;
    }


    @Override public String getMetricShort() { return METRIC_SHORT; }

    @Override public String getUiString() { return uiString; }

    @Override public String getApiString() { return apiString; }

    public static final ExploitMaturity fromText(final String text) {
        switch (text) {
            case "X", "x" -> { return NOT_DEFINED; }
            case "H", "h" -> { return HIGH; }
            case "A", "a" -> { return ATTACKED; }
            case "P", "p" -> { return PROOF_OF_CONCEPT; }
            case "U", "u" -> { return UNREPORTED; }
            case "F", "f" -> { return FUNCTIONAL; }
            default       -> { return NOT_FOUND; }
        }
    }

    public static final ExploitMaturity fromVectorString(final String text) {
        if (null == text || !text.contains(":")) { return NOT_FOUND; }
        final String[] parts = text.split(":");
        if (!parts[0].strip().toUpperCase().equals(ExploitMaturity.METRIC_SHORT)) { return NOT_FOUND; }
        return fromText(parts[1].strip());
    }
}
